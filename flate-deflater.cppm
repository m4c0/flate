export module flate:deflater;
import :bitstream;
import :buffer;
import :details;
import :symbols;
import traits;

using namespace traits::ints;

namespace flate {
export class deflater {
  bitstream *m_bits{};
  tables::huff_tables m_tables{};
  buffer<> m_buffer{};
  unsigned m_len{};
  bool m_last_block{};
  bool m_uncompressed{};

  [[nodiscard]] constexpr mno::req<void> read_huff0_len() {
    return m_bits->align()
        .fmap([this] { return m_bits->next<8>() + (m_bits->next<8>() << 8); })
        .map([this](auto len) { m_len = len; })
        .fmap([this] {
          return m_bits->skip<16>(); // NLEN
        });
  }
  [[nodiscard]] constexpr mno::req<void> read_huff2_tables() {
    return details::read_hc_format(m_bits).fmap([this](auto &fmt) {
      return details::read_hclens(m_bits, fmt).fmap([&](auto &lens) {
        return details::read_hlit_hdist(fmt, lens, m_bits)
            .map([&](auto &hlit_hdist) {
              m_tables = tables::create_tables(hlit_hdist, fmt.hlit);
            });
      });
    });
  }

public:
  explicit constexpr deflater() = default;

  [[nodiscard]] constexpr mno::req<void> set_next_block(bitstream *b) {
    m_bits = b;

    return m_bits->next<1>()
        .map([this](auto b) { m_last_block = b == 1; })
        .fmap([this] { return m_bits->next<2>(); })
        .fmap([this](auto b) -> mno::req<void> {
          switch (b) {
          case 0:
            m_uncompressed = true;
            return read_huff0_len();
          case 1:
            m_uncompressed = false;
            m_tables = tables::create_fixed_huffman_table();
            return {};
          case 2: {
            m_uncompressed = false;
            return read_huff2_tables();
          }
          default:
            return mno::req<void>::failed("unsupported huffman encoding");
          }
        });
  }

  [[nodiscard]] constexpr mno::req<mno::opt<uint8_t>> next() {
    //assert(m_bits != nullptr);
    if (m_uncompressed) {
      if (m_len == 0) {
        return {};
      }
      m_len--;
      return m_bits->next<8>().map([](uint8_t n) { return mno::opt{n}; });
    }
    if (m_buffer.empty()) {
      return symbols::read_next_symbol(m_tables, m_bits)
          .map([this](auto sym) -> mno::opt<uint8_t> {
            if (!m_buffer.visit(sym)) {
              m_bits = nullptr;
              return {};
            }
            return mno::opt<uint8_t>{m_buffer.read()};
          });
    }
    return mno::req{mno::opt<uint8_t>{m_buffer.read()}};
  }
  [[nodiscard]] constexpr auto last_block() const noexcept {
    return m_last_block;
  }

  [[nodiscard]] static constexpr auto from(bitstream *first_block) {
    deflater d{};
    return d.set_next_block(first_block).map([&] { return traits::move(d); });
  }
};
} // namespace flate

constexpr const unsigned char real_zip_block_example[410] {
    0x8d, 0x52, 0x4d, 0x6b, 0x83, 0x40, 0x10, 0xbd, 0xfb, 0x2b, 0x06, 0x0b,
    0x21, 0xa1, 0x98, 0x98, 0xd4, 0xe4, 0xa0, 0x78, 0x28, 0xb4, 0xf7, 0xde,
    0x9b, 0x22, 0xdb, 0xdd, 0x31, 0x91, 0xe8, 0xae, 0xcc, 0xae, 0xc5, 0xa6,
    0xe4, 0xbf, 0x77, 0xd4, 0x7c, 0x11, 0xda, 0xd2, 0xc3, 0xb0, 0xcb, 0x9b,
    0x37, 0xfb, 0xde, 0x1b, 0xbd, 0x2b, 0xb4, 0x2c, 0x1b, 0x85, 0xe0, 0x57,
    0x91, 0x0c, 0x67, 0x82, 0x76, 0xb3, 0x7d, 0x51, 0x4f, 0xd1, 0x48, 0x35,
    0xdd, 0xd6, 0xb5, 0xef, 0x79, 0xb3, 0x19, 0x3c, 0x6b, 0x15, 0x98, 0x3c,
    0x90, 0xa8, 0x1d, 0x89, 0x32, 0x50, 0x05, 0xa1, 0x74, 0x86, 0x3e, 0x61,
    0x2b, 0x2c, 0x08, 0x0d, 0xd8, 0x32, 0x0e, 0xd2, 0x54, 0x15, 0x33, 0xc0,
    0x19, 0x70, 0x68, 0xf9, 0xdc, 0x22, 0x10, 0x7e, 0x20, 0x59, 0x04, 0x8b,
    0xb8, 0x63, 0xa6, 0x3a, 0x52, 0x6b, 0xa1, 0x54, 0xa1, 0x37, 0x20, 0x1c,
    0xe4, 0x64, 0xb4, 0xf3, 0xac, 0x13, 0xae, 0x90, 0xfc, 0x84, 0xb6, 0x0e,
    0xdb, 0x9a, 0x40, 0x34, 0xfc, 0x4c, 0xe7, 0x22, 0x53, 0xc2, 0x09, 0x48,
    0xa1, 0xb3, 0x17, 0xc7, 0x85, 0x89, 0x63, 0x89, 0x19, 0xa1, 0x50, 0x48,
    0xf0, 0xe5, 0x01, 0xf8, 0xeb, 0x76, 0x19, 0xae, 0xdb, 0xe8, 0x7d, 0xdd,
    0x86, 0x73, 0xae, 0x05, 0x57, 0xe8, 0x03, 0xbb, 0x66, 0x91, 0x9b, 0xfe,
    0x92, 0x6b, 0xd5, 0xf5, 0xaf, 0xcb, 0x1f, 0x48, 0xfd, 0x70, 0x78, 0x39,
    0x23, 0xfc, 0x81, 0x14, 0x2d, 0x6e, 0xa7, 0xb9, 0x1e, 0xfa, 0x66, 0x10,
    0x04, 0x67, 0xd5, 0x43, 0xe2, 0x79, 0x8d, 0xed, 0x02, 0x6a, 0x51, 0xa1,
    0xad, 0x85, 0xc4, 0xa3, 0x7f, 0xde, 0x6f, 0x1c, 0xf3, 0x82, 0x99, 0x30,
    0x44, 0xce, 0x84, 0xb5, 0x48, 0x6e, 0xfc, 0xfa, 0xd6, 0xa7, 0xb9, 0x2c,
    0xa0, 0xbf, 0x0d, 0x6b, 0x10, 0xb9, 0x43, 0xca, 0xea, 0xdd, 0x72, 0x95,
    0xd5, 0xc6, 0xf2, 0x2e, 0x96, 0x70, 0x0f, 0x51, 0xd2, 0xa9, 0xbd, 0x3c,
    0x3e, 0xf1, 0xbd, 0x79, 0x58, 0x78, 0x3c, 0xdc, 0x93, 0x89, 0xfb, 0xe7,
    0xbd, 0x25, 0x8c, 0xe6, 0x85, 0x56, 0x59, 0x8f, 0xb0, 0x22, 0x2b, 0x8d,
    0x68, 0xd2, 0xc1, 0x84, 0xae, 0x21, 0x0d, 0x34, 0x75, 0x58, 0x96, 0x9b,
    0xf1, 0x04, 0xd2, 0xf4, 0x46, 0x28, 0xf1, 0x0e, 0xe3, 0x09, 0x73, 0xff,
    0x6f, 0x54, 0xaa, 0x2a, 0xb3, 0xc5, 0x1e, 0xd9, 0x42, 0xc8, 0x0b, 0x4c,
    0xfe, 0xe2, 0x99, 0x3c, 0xb7, 0xe8, 0x06, 0xe6, 0x22, 0xf9, 0xdd, 0xfe,
    0x69, 0x80, 0xf1, 0xee, 0xab, 0xf7, 0x49, 0x6e, 0x32, 0x70, 0x77, 0x2a,
    0x4d, 0xc3, 0xbf, 0x1e, 0x67, 0x98, 0xc3, 0x68, 0xd4, 0x23, 0x83, 0x91,
    0xf4, 0x62, 0xea, 0x88, 0x9f, 0x84, 0xd3, 0x2b, 0x1b, 0xa7, 0xa8, 0xdf,
};
static_assert([] {
  bitstream b { real_zip_block_example, 410 };
  return flate::deflater::from(&b)
      .assert([](auto &d) { return d.next() == '#'; }, "#")
      .assert([](auto &d) { return d.next() == 'i'; }, "i")
      .assert([](auto &d) { return d.next() == 'n'; }, "n")
      .map([](auto &) { return true; })
      .unwrap(false);
}());
static_assert([] {
  const unsigned char data[] {
      1,     // Last bit + Uncompressed
      2, 0,  // LEN
      0, 0,  // NLEN
      93, 15 // DATA
  };
  bitstream b { data, 7 };
  return flate::deflater::from(&b)
      .assert([](auto &d) { return d.next() == 93; }, "93")
      .assert([](auto &d) { return d.next() == 15; }, "15")
      .fmap([](auto &d) { return d.next(); })
      .map([](auto b) { return !b; })
      .unwrap(false);
}());
static_assert([] {
  static constexpr const auto has_ended = [](auto &d) {
    return d.next().map([](auto n) { return !n; }).unwrap(false);
  };

  // Tests with fixed huffman table
  // H = 00110000 + 01001000 = 01111000
  const unsigned char buf1[] { 0b11110011, 0, 0 };
  bitstream b1 { buf1, 3 };
  // E = 00110000 + 01000101 = 01110101
  // Y = 00110000 + 01011001 = 10001001
  const unsigned char buf2[] { 0b01110011, 0b10001101, 0b100, 0 };
  bitstream b2 { buf2, 4 };
  // repeat{3, 3} = {257, 2} = {0000001, 00010}
  const unsigned char buf3[] { 0b00000011, 0b0100010, 0 };
  bitstream b3 { buf3, 3 };

  return flate::deflater::from(&b1)
      .assert([](auto &d) { return d.next() == 'H'; }, "H")
      .assert(has_ended, "")
      .fpeek([&](auto &d) { return d.set_next_block(&b2); })
      .assert([](auto &d) { return d.next() == 'E'; }, "E")
      .assert([](auto &d) { return d.next() == 'Y'; }, "Y")
      .assert(has_ended, "")
      .fpeek([&](auto &d) { return d.set_next_block(&b3); })
      .assert([](auto &d) { return d.next() == 'H'; }, "H")
      .assert([](auto &d) { return d.next() == 'E'; }, "E")
      .assert([](auto &d) { return d.next() == 'Y'; }, "Y")
      .assert(has_ended, "")
      .map([](auto &) { return true; })
      .unwrap(false);
}());
